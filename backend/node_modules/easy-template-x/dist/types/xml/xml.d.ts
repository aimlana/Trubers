import { XmlGeneralNode, XmlNode } from "./xmlNode";
import { XmlCommentNode } from "./xmlNode";
import { XmlTextNode } from "./xmlNode";
import type { IMap } from "src/types";
export type XmlNodePredicate = (node: XmlNode) => boolean;
export declare class XmlUtils {
    readonly parser: Parser;
    readonly create: Create;
    readonly query: Query;
    readonly modify: Modify;
}
declare class Parser {
    private static xmlFileHeader;
    private static readonly parser;
    parse(str: string): XmlNode;
    domParse(str: string): Document;
    encodeValue(str: string): string;
    serializeNode(node: XmlNode): string;
    serializeFile(xmlNode: XmlNode): string;
}
interface XmlGeneralNodeInit {
    attributes?: IMap<string>;
    childNodes?: XmlNode[];
}
declare class Create {
    textNode(text?: string): XmlTextNode;
    generalNode(name: string, init?: XmlGeneralNodeInit): XmlGeneralNode;
    commentNode(text?: string): XmlCommentNode;
    cloneNode<T extends XmlNode>(node: T, deep: boolean): T;
    fromDomNode(domNode: Node): XmlNode;
}
declare class Query {
    isTextNode(node: XmlNode): node is XmlTextNode;
    isGeneralNode(node: XmlNode): node is XmlGeneralNode;
    isCommentNode(node: XmlNode): node is XmlCommentNode;
    lastTextChild(node: XmlNode, createIfMissing?: boolean): XmlTextNode;
    findParent(node: XmlNode, predicate: (node: XmlNode) => boolean): XmlNode;
    findParentByName(node: XmlNode, nodeName: string): XmlNode;
    findChild(node: XmlNode, predicate: (node: XmlNode) => boolean): XmlNode;
    findChildByName(node: XmlNode, childName: string): XmlNode;
    siblingsInRange(firstNode: XmlNode, lastNode: XmlNode): XmlNode[];
    descendants(node: XmlNode, maxDepth: number, predicate: XmlNodePredicate): XmlNode[];
}
declare class Modify {
    insertBefore(newNode: XmlNode, referenceNode: XmlNode): void;
    insertAfter(newNode: XmlNode, referenceNode: XmlNode): void;
    insertChild(parent: XmlNode, child: XmlNode, childIndex: number): void;
    appendChild(parent: XmlNode, child: XmlNode): void;
    remove(node: XmlNode): void;
    removeChild(parent: XmlNode, child: XmlNode): XmlNode;
    removeChild(parent: XmlNode, childIndex: number): XmlNode;
    removeChildren(parent: XmlNode, predicate: (child: XmlNode) => boolean): void;
    removeSiblings(from: XmlNode, to: XmlNode): XmlNode[];
    splitByChild(parent: XmlNode, child: XmlNode, removeChild: boolean): [XmlNode, XmlNode];
    removeEmptyTextNodes(node: XmlNode): void;
}
export declare const xml: XmlUtils;
export {};
